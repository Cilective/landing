<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cilective – Optimize your CI pipeline</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
<!-- Hero section -->
<section class="hero-section">
  <div class="hero-background">
    <div id="stars" class="layer"></div>
    <canvas id="links1" class="links"></canvas>

    <div id="stars2" class="layer"></div>
    <canvas id="links2" class="links"></canvas>

    <div id="stars3" class="layer"></div>
<!--    <canvas id="links3" class="links"></canvas>-->
  </div>
  <div class="hero-content">
    <h1>
      Ship <span class="primary">Faster</span> with Selective Test Runs
    </h1>
    <p>
      Save time and reduce CI costs by running only the tests affected by your changes.
    </p>
    <a href="#signup" class="cta-btn">Sign Up for Early Access</a>
    <div class="brand-identity">
      <img class="brand-wordmark" src="images/lw-white.svg" alt="Cilective" aria-label="Cilective wordmark" />
    </div>
  </div>
</section>

<!-- Benefits section -->
<section class="benefits-section">
  <h2>Why <span class="primary">Cilective</span>?</h2>
  <div class="benefits-list">
    <!-- Benefit 1 -->
    <div class="benefit-card">
      <div class="svg-placeholder"></div>
      <div class="benefit-text">
        <h4>Ship Faster With Targeted Tests</h4>
        <p>
          Cilective selects the minimal set of tests affected by every pull request, 
          accelerating how fast your team can merge and deploy without sacrificing quality.
        </p>
      </div>
    </div>
    <!-- Benefit 2 -->
    <div class="benefit-card">
      <div class="svg-placeholder"></div>
      <div class="benefit-text">
        <h4>Wait Less, Build More</h4>
        <p>
          Spend less time waiting for CI, no need to switch to something else, just keep building.
        </p>
      </div>
    </div>
    <!-- Benefit 3 -->
    <div class="benefit-card">
      <div class="svg-placeholder"></div>
      <div class="benefit-text">
        <h4>Keep CI Efficient as You Grow</h4>
        <p>
          As your codebase and team scale, Cilective keeps CI time (and cost) under control by selecting relevant tests.
        </p>
      </div>
    </div>
    <!-- Benefit 4 -->
    <div class="benefit-card">
      <div class="svg-placeholder"></div>
      <div class="benefit-text">
        <h4>Understand Change Impact</h4>
        <p>
          Visualize the “blast radius” of each pull request so you can assess risk, 
          catch surprises early and merge with confidence.
        </p>
      </div>
    </div>
  </div>
</section>

<!-- How it works -->
<section class="how-section">
  <h2>How It Works</h2>
  <div class="how-cards">
    <!-- Feature 1 -->
    <div class="how-card">
      <div class="svg-placeholder"></div>
      <h3>Performant Test Selection</h3>
      <p>
        Cilective builds a dependency graph from your code to identify the subset of tests affected by any change, 
        including indirect dependencies from frameworks and dynamic calls.
        <br><br>
        Cilective is designed to work with large codebases and mono-repos, with data streaming and parallel analysis.
      </p>
    </div>
    <!-- Feature 2 -->
    <div class="how-card">
      <div class="svg-placeholder"></div>
      <h3>Seamless and Secure</h3>
      <p>
        Add Cilective to your existing CI workflow with just a few lines, no migration or refactoring required. 
        Turn Cilective on or off any time, with no lock-in.
        <br><br>
        Security is built in from day one; we never store your source code and require minimal permissions.
      </p>
    </div>
    <!-- Feature 3 -->
    <div class="how-card">
      <div class="svg-placeholder"></div>
      <h3>Modern Stack Ready</h3>
      <p>
        Cilective is designed to support the languages and test frameworks that real engineering teams use today.
        <br><br>
        Our initial release supports C# and .NET, with JavaScript and Python on our roadmap. Have a different stack?
        Let us know; your feedback tells us what we build next.
      </p>
    </div>
  </div>
</section>

<!-- Signup section -->
<section id="signup" class="signup-section">
  <h2>Sign Up for Early Access</h2>
  <form id="signupForm" class="signup-form">
    <div class="signup-form-fields">
      <div class="form-field">
        <label for="name">Name</label>
        <input type="text" id="name" name="name" placeholder="Name" required />
      </div>
      <div class="form-field">
        <label for="email">Email</label>
        <input type="email" id="email" name="email" placeholder="Email" required />
      </div>
      <div class="form-field">
        <label for="company">Company</label>
        <input type="text" id="company" name="company" placeholder="Company" />
      </div>
      <div class="form-field">
        <label for="role">Role</label>
        <input type="text" id="role" name="role" placeholder="Role" />
      </div>
    </div>
    <div class="submit-row">
      <button type="submit">Sign Up</button>
    </div>
  </form>
  <script>
    document.getElementById("signupForm").addEventListener("submit", async function(e){
      e.preventDefault();
      const data = {
        name: document.getElementById("name").value,
        email: document.getElementById("email").value,
        company: document.getElementById("company").value,
        role: document.getElementById("role").value,
      };
      await fetch("", {
        method: "POST",
        body: JSON.stringify(data),
        headers: { "Content-Type": "application/json" }
      });
      alert("Thanks for signing up!");
    });
  </script>
</section>

<!-- Footer -->
<footer>
  <p>
    &copy; 2025 Cilective. All rights reserved. Built with ♥ to help
    developers ship faster.
  </p>
</footer>

<script>
  (() => {
    // ===== Config =====
    const SIZE = 2000; // must match CSS translate range and :after top
    const LAYERS = [
      { id: 'stars',  canvas: 'links1', count: 700,  maxDist: 55,  lineWidth: 0.5, duration: 50 },
      { id: 'stars2', canvas: 'links2', count: 200,  maxDist: 70,  lineWidth: 0.6, duration: 100 },
      { id: 'stars3', canvas: 'links3', count: 100,  maxDist: 90,  lineWidth: 0.8, duration: 150 },
    ];

    // ===== Utilities =====
    const rnd = (n) => Math.floor(Math.random() * n);

    function makePoints(n) {
      const pts = new Array(n);
      for (let i = 0; i < n; i++) pts[i] = { x: rnd(SIZE), y: rnd(SIZE) };
      return pts;
    }

    function pointsToBoxShadow(points) {
      // "xpx ypx #FFF, ..."
      return points.map(p => `${p.x}px ${p.y}px #FFF`).join(',\n');
    }

    function drawConnections(canvas, points, { maxDist, lineWidth }) {
      const dpr = window.devicePixelRatio || 1;
      canvas.width  = SIZE * dpr;
      canvas.height = SIZE * dpr;
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, SIZE, SIZE);
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = '#FFFFFF';

      // Spatial hash grid to avoid O(n^2)
      const cell = maxDist;
      const cols = Math.ceil(SIZE / cell);
      const grid = new Map();
      const key = (cx, cy) => (cx << 16) | cy;

      for (let i = 0; i < points.length; i++) {
        const p = points[i];
        const cx = (p.x / cell) | 0;
        const cy = (p.y / cell) | 0;
        const k = key(cx, cy);
        let arr = grid.get(k);
        if (!arr) grid.set(k, (arr = []));
        arr.push({ i, p });
      }

      function neighbors(cx, cy) {
        const out = [];
        for (let y = cy - 1; y <= cy + 1; y++) {
          for (let x = cx - 1; x <= cx + 1; x++) {
            const arr = grid.get(key(x, y));
            if (arr) out.push(...arr);
          }
        }
        return out;
      }

      ctx.beginPath();
      const max2 = maxDist * maxDist;

      for (let i = 0; i < points.length; i++) {
        const p = points[i];
        const cx = (p.x / cell) | 0;
        const cy = (p.y / cell) | 0;
        const nbs = neighbors(cx, cy);

        for (const nb of nbs) {
          if (nb.i <= i) continue; // avoid duplicates
          const q = nb.p;
          const dx = p.x - q.x, dy = p.y - q.y;
          const d2 = dx*dx + dy*dy;
          if (d2 <= max2) {
            const d = Math.sqrt(d2);
            const a = Math.max(0.08, 1 - d / maxDist); // soft fade by distance
            ctx.globalAlpha = a;
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(q.x, q.y);
          }
        }
      }
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // ===== Init =====
    function initLayer({ id, canvas, count, maxDist, lineWidth }) {
      // Generate star positions
      const pts = makePoints(count);

      // Set CSS custom properties so both the element and its ::after can use them
      const root = document.documentElement;
      if (id === 'stars')  root.style.setProperty('--shadows-small',  pointsToBoxShadow(pts));
      if (id === 'stars2') root.style.setProperty('--shadows-medium', pointsToBoxShadow(pts));
      if (id === 'stars3') root.style.setProperty('--shadows-big',    pointsToBoxShadow(pts));

      // Build combined list including the ::after stars (offset by +SIZE in Y)
      const ptsAfter = pts.map(p => ({ x: p.x, y: p.y + SIZE }));
      const combined = pts.concat(ptsAfter);

      // Draw the connection lines once (the canvas bitmap is animated via CSS)
      const cv = document.getElementById(canvas);
      if (cv)
        drawConnections(cv, combined, { maxDist, lineWidth });
    }

    function init() {
      // Ensure CSS animation distance matches SIZE
      document.documentElement.style.setProperty('--field-size', SIZE + 'px');
      LAYERS.forEach(initLayer);
    }

    window.addEventListener('load', init);
  })();
</script>
</body>
</html>